package pgex;
option optimize_for = LITE_RUNTIME;

message Data {
  /// version of the protocol / data format. readonly !! (== the major of the pgex project version)
  optional uint32 version = 1 [default = 0];
  repeated Relation relations = 2;
  repeated TObject tobjects = 3;
  repeated Geometry geometries = 4;
  repeated Material materials = 5;
  repeated Light lights = 6;

  /// reserved for application specific data, no requirement to be managed by others application.
  /// eg: custom primitive properties, node material, particle, internal/private data to allow save/load
  /// Only require to avoid collision in index.
  extensions 500 to 2000;
}

/// Define a Relation (edge, link) between two objects with an id
/// rules:
/// * typename of obj with id == ref1 < typename of obj with id == ref2
message Relation {
  /// reference the id of object 1
  required string ref1 = 1;
  /// reference the id of object 1
  required string ref2 = 2;
  /// mainly for description but often useless
  optional string label = 3;
}

message Geometry {
  /// identifier (id) should be unique and invariant over a set of datas (eg: use uuid) and over time.
  required string id = 1;
  repeated Mesh meshes = 2;
  /// display name
  optional string name = 3;
  //repeated Morph morphs = 3 [packed=true];
  //visible bool true Whether the geometry is visible.
  //If the visible property is false, then the geometry should not be rendered but should still
  //shadow bool true Whether the geometry casts shadows.
  //motion_blur bool true Whether the geometry is rendered with motion blur.
}

message Mesh {
  enum Primitive {
    /// "points" The mesh is composed of a set of independent points. The number of points is n, and point i is given by vertex i.
    points = 1;
    /// "lines" The mesh is composed of a set of independent lines. The number of lines is n / 2 , and line i is composed of vertices 2i and 2i+1 .
    lines = 2;
    /// "line_strip" The mesh is composed of one or more line strips. The number of lines is  n - 1 , and line i is composed of vertices i and i + 1 .
    line_strip = 3;
    /// "triangles" The mesh is composed of a set of independent triangles. The number of triangles is n/3 , and triangle i is composed of vertices 3i , 3i + 1 , and 3i + 2.
    triangles = 4;
    /// "triangle_strip" The mesh is composed of one or more triangle strips. The number of triangles is n - 2 , and triangle i is composed of vertices i, i + 1 , and i + 2 when i is even or vertices i, i + 2 , and i + 1 when i is odd, in the orders listed.
    triangle_strip = 5;
  }
  /// identifier (id) should be unique and invariant over a set of datas (eg: use uuid) and over time.
  required string id = 1;
  required Primitive primitive = 2;
  optional uint32 lod = 3 [default = 0];
  repeated VertexArray vertexArrays = 4;
  repeated IndexArray indexArrays = 5;
  /// display name
  optional string name = 6;
  // optional Skin skin = 6;
}

message VertexArray {
  enum Attrib {
    position = 1;
    normal = 2;
    tangent = 3;
    bitangent = 4;
    color = 5;
    texcoord = 6;
    texcoord2 = 7;
    texcoord3 = 8;
    texcoord4 = 9;
    texcoord5 = 10;
    texcoord6 = 11;
    texcoord7 = 12;
    texcoord8 = 13;
    texcoord9 = 14;
  }
  required Attrib attrib = 1;
  optional uint32 morph = 2 [default = 0];
  oneof buffer {
    FloatBuffer floats = 3;
    //DoubleBuffer doubles = 4;
  }
}

message IndexArray {
  oneof buffer {
    UintBuffer ints = 1;
  }
}

message FloatBuffer {
  repeated float values = 1 [packed = true];
  /// number of float per group/entry (eg 3 for vec3, 2 for texcoord,...). the length of values should be a multiple of step
  required uint32 step = 2 [default = 1];
}
// message DoubleBuffer {
//   repeated double values = 1 [packed = true];
//   /// number of float per group/entry (eg 3 for vec3, 2 for texcoord,...). the length of values should be a multiple of step
//   required uint32 step = 2 [default = 1];
// }
message UintBuffer {
  repeated uint32 values = 1 [packed = true];
  /// number of float per group/entry (eg 3 for vec3, 2 for texcoord,...). the length of values should be a multiple of step
  required uint32 step = 2 [default = 1];
}

// message Skin {
//   optional Transform transform = 2;
//   required Skeleton skeleton = 3;
//   required BoneCountArray boneCountArray= 4;
//   required BoneIndexArray boneIndexArray = 5;
//   required BoneWeightArray boneWeightArray = 6;
// }

message Material {
  /// identifier (id) should be unique and invariant over a set of datas (eg: use uuid) and over time.
  required string id = 1;
  repeated MaterialParam params = 2;
  optional string family = 3;
  /// display name
  optional string name = 4;
}

message MaterialParam {
  enum Attrib {
    /// base color could be used for unshaded, or as base color in PBR, or as diffuse
    color = 1;
    roughness = 2;
    metalness = 3;
    specular = 4;
    specular_power = 5;
    emission = 6;
    opacity = 7;
    //transparency = 8;
    normal = 9;
  }
  required Attrib attrib = 1;
  oneof value {
    Color vcolor = 2;
    float vfloat = 3;
    int32 vint = 4;
    Vec2 vvec2 = 5;
    Vec3 vvec3 = 6;
    Vec4 vvec4 = 7;
    Quaternion vquat = 8;
    Mat4 vmat4 = 9;
    string vstring = 10;
    Texture vtexture = 11;
    bool vbool = 12;
  }
}
/// the direction of the light need by directional and spot is Z (forward like regular Node).
/// To use an other direction add relation to a Node and change the rotation of the Node (idem for translation).
message Light {
  enum Kind {
    ambient = 1;
    directional = 2;
    point = 3;
    spot = 4;
  }
  /// identifier (id) should be unique and invariant over a set of datas (eg: use uuid) and over time.
  required string id = 1;
  optional Kind kind = 2 [default = directional];
  optional Color color = 3;
  optional float intensity = 4 [default = 1.0];
  optional bool cast_shadow = 5 [default = false];
  /// attenuation from the radial distance of light source (for spot and point)
  optional Attenuation radial_distance = 6;
  /// attenuation of the angle forme between the forward axis (z) and the direction of the point.
  /// eg: for a linear attenuation linear.begin is the end of inner cone, linear.end is the end of outer cone : linear define the penumbra
  optional Attenuation spot_angle = 7;
  /// display name
  optional string name = 8;
}

message Attenuation {
  ///  for a distance max is in meter, for an angle attenuation max is in radian.
  required float max = 1;
  oneof curve {
    AttenuationLinear linear = 4;
    AttenuationSmooth smooth = 5;
    AttenuationInverse inverse = 6;
    AttenuationInverseSquare inverse_square = 7;
  }
}
message AttenuationLinear {
  optional float begin = 4 [default = 0.0];
  optional float end = 5 [default = 1.0];
}
message AttenuationSmooth {
  optional float begin = 4 [default = 0.0];
  optional float end = 5 [default = 1.0];
}
message AttenuationInverse {
  optional float scale = 2 [default = 1.0];
  optional float offset = 3 [default = 0.0];
  optional float constant = 4 [default = 0.0];
  optional float linear = 5 [default = 1.0];
}
message AttenuationInverseSquare {
  optional float scale = 2 [default = 1.0];
  optional float offset = 3 [default = 0.0];
  optional float constant = 4 [default = 0.0];
  optional float linear = 5 [default = 0.0];
  optional float quadratic = 6 [default = 1.0];
}

message TObject {
  /// identifier (id) should be unique and invariant over a set of datas (eg: use uuid) and over time.
  required string id = 1;
  repeated Transform transforms = 2;
  /// id of the parent node. if undefined root of the scene is the parent
  optional string parentId = 3;
  /// display name
  optional string name = 4;
}

message Transform {
  required Vec3 translation = 1;
  required Quaternion rotation = 2;
  required Vec3 scale = 3;
}

// message Morph {
//   required string id = 1;
//   /// the morph targer index
//   required uint32 index = 2 [default = 0];
//   /// the base morph target index for relative morph target.
//   optional uint32 base = 3;
// }
message Vec2 {
  required float x = 1;
  required float y = 2;
}

message Vec3 {
  required float x = 1;
  required float y = 2;
  required float z = 3;
}

message Vec4 {
  required float x = 1;
  required float y = 2;
  required float z = 3;
  required float w = 4;
}

message Color {
  required float r = 1;
  required float g = 2;
  required float b = 3;
  required float a = 4;
}


message Texture {
  optional string name = 1;
  oneof data {
    /// path of the texture relative to asset root folder (use '/' as folder separator)
    string rpath = 2;
    Texture2DInline tex2d = 3;
  }
}

message Texture2DInline {
  enum Format {
    rgb8 = 1;
    rgba8 = 2;
    bgra8 = 3;
  }
  required Format format = 1;
  required uint32 width = 2;
  required uint32 height = 3;
  required bytes data = 4;
}

/// Quaternion should be normalized
message Quaternion {
  required float x = 1;
  required float y = 2;
  required float z = 3;
  required float w = 4;
}

message Mat4 {
  required float c00 = 1;
  required float c10 = 2;
  required float c20 = 3;
  required float c30 = 4;
  required float c01 = 5;
  required float c11 = 6;
  required float c21 = 7;
  required float c31 = 8;
  required float c02 = 9;
  required float c12 = 10;
  required float c22 = 11;
  required float c32 = 12;
  required float c03 = 13;
  required float c13 = 14;
  required float c23 = 15;
  required float c33 = 16;
}
